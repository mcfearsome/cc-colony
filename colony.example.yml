# Colony Configuration Example
# This file demonstrates all available configuration options

# Optional: Name for this colony (defaults to directory name)
# name: my-project

# Optional: Repository configuration - defines the repository's purpose and role
# This helps agents understand the type of work they'll be doing
# repository:
#   repo_type: source  # source | memory | application | research | documentation
#   purpose: "Main application codebase for Project Alpha"
#   context: |
#     This repository contains the full-stack web application.
#     Backend: Node.js/Express, Frontend: React, Database: PostgreSQL

# EXAMPLE REPOSITORY CONFIGURATIONS:

# Source Code Repository (default):
# repository:
#   repo_type: source
#   purpose: "E-commerce platform backend and frontend"
#   context: "Monorepo with microservices architecture"

# Memory/Knowledge Base Repository:
# repository:
#   repo_type: memory
#   purpose: "Team knowledge base and decision records"
#   context: |
#     Store research findings, technical decisions (ADRs), meeting notes,
#     and project documentation. Use markdown files organized by topic.

# Agent Application Repository:
# repository:
#   repo_type: application
#   purpose: "Multi-agent customer support system"
#   context: |
#     This repository IS the agent application. Agents provide customer
#     support through intelligent routing and response generation.

# Research Repository:
# repository:
#   repo_type: research
#   purpose: "Market analysis and competitive intelligence"
#   context: "Data analysis, report generation, and insight extraction"

# Documentation Repository:
# repository:
#   repo_type: documentation
#   purpose: "Product documentation and user guides"
#   context: "Technical writing, API documentation, tutorials"

agents:
  # Example 1: Backend agent with filesystem MCP server
  - id: backend-1
    role: Backend Engineer
    focus: API endpoints and server logic
    model: claude-opus-4-20250514
    # Optional: Custom directory (uses git worktree if not specified)
    # directory: ~/projects/my-backend
    # Optional: Worktree name (defaults to agent ID if not specified)
    # worktree: shared-backend
    # Optional: Environment variables for this agent
    env:
      NODE_ENV: development
      DEBUG: "api:*"
    # Optional: MCP servers for this agent
    mcp_servers:
      filesystem:
        command: npx
        args:
          - -y
          - "@modelcontextprotocol/server-filesystem"
          - /path/to/allowed/directory

  # Example 2: Frontend agent with multiple MCP servers
  - id: frontend-1
    role: Frontend Engineer
    focus: React components and UI implementation
    model: claude-sonnet-4-20250514
    mcp_servers:
      # Browser automation for testing
      puppeteer:
        command: npx
        args:
          - -y
          - "@modelcontextprotocol/server-puppeteer"
      # Git integration
      git:
        command: uvx
        args:
          - mcp-server-git
          - --repository
          - /path/to/repo

  # Example 3: DevOps agent with custom environment variables
  - id: devops-1
    role: DevOps Engineer
    focus: Infrastructure and deployment
    model: claude-opus-4-20250514
    directory: ~/projects/infrastructure
    mcp_servers:
      # AWS integration with credentials
      aws:
        command: npx
        args:
          - -y
          - "@modelcontextprotocol/server-aws"
        env:
          AWS_REGION: us-west-2
          AWS_PROFILE: default
      # Docker management
      docker:
        command: docker-mcp-server

  # Example 4: Database agent with PostgreSQL MCP server
  - id: database-1
    role: Database Engineer
    focus: Schema design and query optimization
    model: claude-sonnet-4-20250514
    mcp_servers:
      postgres:
        command: npx
        args:
          - -y
          - "@modelcontextprotocol/server-postgres"
        env:
          POSTGRES_CONNECTION_STRING: postgresql://localhost:5432/mydb

  # Example 5: Agent without MCP servers (uses defaults or repo settings)
  - id: docs-1
    role: Documentation Specialist
    focus: Writing and maintaining documentation
    model: claude-sonnet-4-20250514
    # No MCP servers configured - will use repo's .claude/settings.json if present

  # Example 6: Multiple agents sharing the same worktree
  - id: review-1
    role: Code Reviewer
    focus: Review backend changes
    model: claude-opus-4-20250514
    worktree: shared-review  # Shares worktree with review-2
    env:
      REVIEWER_ROLE: backend

  - id: review-2
    role: Code Reviewer
    focus: Review frontend changes
    model: claude-opus-4-20250514
    worktree: shared-review  # Shares worktree with review-1
    env:
      REVIEWER_ROLE: frontend

  # Example 7: Agent with extensive environment configuration
  - id: integration-test
    role: Integration Tester
    focus: Run integration tests
    model: claude-sonnet-4-20250514
    env:
      TEST_ENV: integration
      DATABASE_URL: postgresql://localhost:5432/test_db
      REDIS_URL: redis://localhost:6379
      API_KEY: test_key_12345
      LOG_LEVEL: debug

  # Example 8: Agent with custom instructions
  - id: security-auditor
    role: Security Auditor
    focus: Review code for security vulnerabilities
    model: claude-opus-4-20250514
    instructions: |
      Your mission is to identify security vulnerabilities in the codebase.

      Focus areas:
      - SQL injection vulnerabilities
      - XSS (Cross-Site Scripting) issues
      - Authentication and authorization flaws
      - Insecure data handling
      - CSRF protection

      When you find an issue:
      1. Document the vulnerability with a clear explanation
      2. Assess the severity (Critical, High, Medium, Low)
      3. Provide a code example of the fix
      4. Create a task in the task queue for remediation

      Always follow OWASP Top 10 guidelines.

  # Example 9: Agent with completely custom startup prompt
  - id: specialized-agent
    role: Specialized Agent
    focus: Custom workflow
    model: claude-opus-4-20250514
    # startup_prompt completely replaces the default colony prompt
    # Use this when you need full control over the agent's initial instructions
    startup_prompt: |
      # Custom Agent Startup

      You are a specialized agent with a unique workflow.

      ## Your Mission
      Focus exclusively on refactoring legacy code to improve maintainability.

      ## Workflow
      1. Scan for code smells and anti-patterns
      2. Prioritize refactoring opportunities by impact
      3. Create detailed refactoring plans
      4. Implement changes incrementally
      5. Ensure all tests pass after each change

      ## Guidelines
      - Never refactor without tests
      - Keep commits atomic and well-documented
      - Preserve existing functionality
      - Improve code clarity and readability

      ## Communication (Optional)
      While you have a custom startup, you can still use the colony messaging system:
      ```bash
      ./colony_message.sh send all "Starting refactoring on [module]"
      ```

      Now begin your work!

# Optional: MCP Executor configuration
# The executor provides a dedicated pane for running complex multi-tool MCP workflows
# Other agents can send MCP tasks to the executor via colony messages
executor:
  # Enable the MCP executor (default: false)
  enabled: true
  # Agent ID for the executor (default: mcp-executor)
  agent_id: mcp-executor
  # MCP servers for the executor (same format as agent mcp_servers)
  mcp_servers:
    filesystem:
      command: npx
      args:
        - -y
        - "@modelcontextprotocol/server-filesystem"
        - /tmp
    database:
      command: uvx
      args:
        - mcp-server-sqlite
        - --db-path
        - /path/to/database.sqlite
  # Supported languages for MCP execution (default: [typescript, python])
  languages:
    - typescript
    - python

# Configuration Notes:
#
# 0. Repository Configuration (New!):
#    - repo_type: Defines the repository's purpose and role
#      * source: Traditional code repository (default)
#      * memory: Knowledge base for notes, research, context
#      * application: Repository IS an agent application
#      * research: Data analysis and report generation
#      * documentation: Technical writing and docs
#    - purpose: Brief description of what the repository is for
#    - context: Additional information agents should know
#    - This information is automatically included in agent startup prompts
#    - Helps agents understand whether they're writing code, organizing knowledge, etc.
#    - See skills for repo-specific guidance:
#      * .claude/skills/knowledge-base.md (for memory repos)
#      * .claude/skills/agent-applications.md (for application repos)
#
# 1. Agent ID Requirements:
#    - Must be unique within the colony
#    - Can only contain alphanumeric characters, hyphens, and underscores
#    - Used for directory names and messaging
#
# 2. Model Options:
#    - claude-opus-4-20250514 (most capable, slower)
#    - claude-sonnet-4-20250514 (balanced, default)
#    - claude-haiku-4-20250514 (fastest, more economical)
#
# 3. Directory Options:
#    - If not specified: Agent works in git worktree at .colony/worktrees/{worktree-name}
#    - If specified: Agent works in that directory (must exist)
#    - Supports ~ for home directory expansion
#
# 4. Worktree Sharing:
#    - worktree field specifies the worktree name (defaults to agent ID)
#    - Multiple agents can share the same worktree by using the same worktree name
#    - Shared worktrees allow agents to collaborate in the same codebase
#    - Only one worktree is created per unique worktree name
#    - Example: Two code reviewers working on different aspects of the same code
#
# 5. Environment Variables:
#    - env field allows setting environment variables for each agent's pane
#    - Variables are exported before running Claude Code
#    - Useful for per-agent configuration (API keys, database URLs, debug flags)
#    - Variables are shell-escaped for security
#    - Example: Different test environments, feature flags, or credentials per agent
#
# 6. Custom Instructions:
#    - instructions field allows adding custom instructions to the agent's startup prompt
#    - Instructions are appended after the standard colony prompt
#    - Sent automatically to Claude when the agent starts via tmux send-keys
#    - Use multi-line strings with | for longer instructions
#    - Perfect for specialized behaviors, focus areas, or workflows
#    - Example: Security checklist, coding standards, specific testing procedures
#
# 6a. Custom Startup Prompt:
#    - startup_prompt field allows complete replacement of the default colony startup prompt
#    - When provided, this completely overrides the default prompt (role, focus, messaging system)
#    - Use this when you need full control over the agent's initial instructions
#    - You can still include colony messaging commands in your custom prompt if needed
#    - Note: If both startup_prompt and instructions are provided, only startup_prompt is used
#    - Example: Specialized agents with unique workflows, non-colony agents, or testing scenarios
#
# 7. MCP Server Configuration:
#    - Each agent can have its own set of MCP servers
#    - Merges with existing .claude/settings.json in the working directory
#    - Agent-specific MCP servers override repo-level settings
#    - Server name is the key (e.g., "filesystem", "git", "aws")
#    - Required fields:
#      * command: The executable to run
#    - Optional fields:
#      * args: Array of command-line arguments
#      * env: Map of environment variables (for the MCP server)
#
# 8. Common MCP Servers:
#    - @modelcontextprotocol/server-filesystem - File system access
#    - @modelcontextprotocol/server-git - Git operations
#    - @modelcontextprotocol/server-github - GitHub API access
#    - @modelcontextprotocol/server-postgres - PostgreSQL database
#    - @modelcontextprotocol/server-puppeteer - Browser automation
#    - @modelcontextprotocol/server-aws - AWS operations
#    - @modelcontextprotocol/server-slack - Slack integration
#
# 9. Settings Merging:
#    - If .claude/settings.json exists in the working directory, it's loaded first
#    - Agent-specific MCP servers are merged in, overriding conflicts
#    - Final merged settings are written to .colony/projects/{agent-id}/.claude/settings.json
#    - Claude Code is invoked with --settings pointing to the merged file
#
# 10. MCP Executor:
#    - The executor is a special agent dedicated to running MCP workflows
#    - Other agents can send MCP task requests via colony messages
#    - Reduces token usage by centralizing MCP operations (up to 98% reduction)
#    - Executor configuration:
#      * enabled: Set to true to enable the executor pane
#      * agent_id: Identifier for the executor (used in messaging)
#      * mcp_servers: MCP server configuration (same format as agent mcp_servers)
#      * languages: Supported execution languages (typescript requires Deno, python requires Python 3.8+)
#    - The executor has its own dedicated pane and message inbox
#    - See .claude/skills/mcp-executor/COLONY-EXECUTOR.md for usage guide
#    - Agents submit tasks using: ./colony_message.sh send mcp-executor "Execute MCP workflow: ..."
#    - MCP servers are configured directly in colony.yml (same as agents)
#    - Example:
#      executor:
#        enabled: true
#        agent_id: mcp-executor
#        mcp_servers:
#          filesystem:
#            command: npx
#            args: ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
#          database:
#            command: uvx
#            args: ["mcp-server-sqlite", "--db-path", "/path/to/db.sqlite"]
#        languages: ["typescript", "python"]

# Optional: Shared State Configuration
# Git-backed state management enables agents to share tasks, workflows, and memory
# across sessions using git as the distributed state layer (Beads-inspired)
shared_state:
  # Backend type: git-backed or memory-only
  backend: git-backed  # Options: git-backed, memory (default: git-backed)

  # Storage location: in-repo or external
  location: in-repo    # Options: in-repo, external (default: in-repo)

  # Path to state directory
  # - For in-repo: relative to repo root (default: .colony/state)
  # - For external: absolute path or ~/path
  path: .colony/state

  # Path to SQLite cache database (relative to repo root)
  cache: .colony/cache/state.db

  # Git branch to use for state
  branch: main

  # Auto-commit changes to git
  auto_commit: true

  # Auto-push commits to remote (only if auto_commit is true)
  auto_push: false

  # Commit message template ({schema} will be replaced with schema name)
  commit_message: "Update colony state ({schema}) [skip ci]"

  # Auto-pull on colony start
  auto_pull: false

  # Sync state when colony starts
  sync_on_start: true

  # Debounce time in milliseconds before exporting to git
  debounce_ms: 5000  # 5 seconds

  # State schemas (files to track)
  schemas:
    - name: tasks
      file: tasks.jsonl
      cache: true
    - name: workflows
      file: workflows.jsonl
      cache: true

# EXAMPLE SHARED STATE CONFIGURATIONS:

# Example 1: In-Repo State (Default)
# State stored in .colony/state/ within the project repository
# Best for: Project-specific state, single-repo workflows
# shared_state:
#   backend: git-backed
#   location: in-repo
#   path: .colony/state
#   auto_commit: true
#   auto_push: false

# Example 2: External Shared State
# State stored in separate git repository, shared across multiple projects
# Best for: Multi-project coordination, team collaboration
# shared_state:
#   backend: git-backed
#   location: external
#   path: ~/.colony/shared-state
#   repository: git@github.com:your-org/colony-state.git
#   project_id: my-project  # Namespace within external repo
#   branch: main
#   auto_commit: true
#   auto_push: true  # Share state with team
#   auto_pull: true  # Get latest state on start

# Example 3: Memory-Only State (Testing/Ephemeral)
# State exists only in memory, not persisted
# Best for: Testing, temporary colonies, throw-away work
# shared_state:
#   backend: memory
#   # Other fields ignored for memory backend

# Example 4: Custom State Configuration
# Fine-tuned configuration for specific workflows
# shared_state:
#   backend: git-backed
#   location: in-repo
#   path: .colony/state
#   cache: .colony/cache/state.db
#   branch: colony-state  # Use separate branch for state
#   auto_commit: true
#   auto_push: false
#   commit_message: "State update: {schema}"
#   sync_on_start: true
#   debounce_ms: 10000  # 10 seconds (less frequent commits)
#   schemas:
#     - name: tasks
#       file: tasks.jsonl
#       cache: true
#     - name: workflows
#       file: workflows.jsonl
#       cache: true
#     - name: memory
#       file: memory.jsonl
#       cache: true  # Add memory schema for agent context

# Configuration Notes for Shared State:
#
# 1. Backend Types:
#    - git-backed: State persisted to JSONL files + git (recommended)
#    - memory: State exists only in RAM (for testing)
#
# 2. Storage Locations:
#    - in-repo: State stored in .colony/state/ within project
#      * Pros: Simple, project-scoped, no setup
#      * Cons: State tied to one repo
#    - external: State in separate git repository
#      * Pros: Share across projects, team collaboration
#      * Cons: Requires external repo setup
#
# 3. Auto-Commit/Push:
#    - auto_commit: true → Changes automatically committed to git
#    - auto_push: true → Commits automatically pushed to remote
#    - Best practice: Enable auto_commit, disable auto_push for local-only
#    - For teams: Enable both to share state automatically
#
# 4. Debouncing:
#    - debounce_ms: Delay before writing to git (prevents excessive commits)
#    - Higher values → Fewer commits, more batching
#    - Lower values → More real-time sync, more commits
#    - Recommended: 5000-10000ms (5-10 seconds)
#
# 5. Schemas:
#    - Define which data types to track (tasks, workflows, memory)
#    - Each schema → separate JSONL file
#    - cache: true → Enable SQLite cache for fast queries
#    - Add custom schemas as needed
#
# 6. External Repository Setup:
#    - Create empty git repo: git init --bare ~/colony-state.git
#    - Or use GitHub: gh repo create your-org/colony-state --private
#    - Set repository URL in config
#    - Set project_id to namespace your project's state
#    - State stored in: {repo}/{project_id}/*.jsonl
#
# 7. Git Operations:
#    - Colony automatically initializes git repo if needed
#    - Commits use configured message template
#    - Pull/push operations handle conflicts gracefully
#    - State files are append-only JSONL (merge-friendly)
#
# 8. Use Cases:
#    - Single developer: in-repo, auto_commit=true, auto_push=false
#    - Team collaboration: external, auto_commit=true, auto_push=true
#    - CI/CD pipelines: memory backend (ephemeral)
#    - Multi-project agents: external with different project_ids
#
#
